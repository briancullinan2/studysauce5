@using System.Reflection
@typeparam TModel

<div class="@containerClass auto-form-container">
    @if (_parameterCache != null)
    {
        @foreach (var entry in _parameterCache)
        {
            <div class="form-field">
                @*<label>@entry.Metadata.PropertyType</label>
                <label>@GetControl(entry.Metadata.PropertyType).Name</label>*@
                @{
                    var controlType = GetControl(entry.Metadata.PropertyType);
                    RenderFragment renderControl = builder =>
                    {
                        builder.OpenComponent(0, controlType);
                        // Manually assign parameters from your dictionary
                        builder.AddAttribute(1, "Model", entry.Metadata);
                        builder.AddAttribute(2, "ValueChanged", entry.Params["ValueChanged"]);
                        builder.AddAttribute(3, "Data", Data);
                        builder.CloseComponent();
                    };
                }
                @renderControl
                @*<DynamicComponent Type="@ControlMapper.GetControl(entry.Metadata.PropertyType)"
                                  Parameters="@entry.Params" />*@
            </div>
        }
    }
</div>

@code {
    [Parameter] public IEnumerable<PropertyMetadata>? Model { get; set; }
    [Parameter] public IEnumerable<TModel>? Data { get; set; }
    string? containerClass;

    private List<(PropertyMetadata Metadata, Dictionary<string, object?> Params)>? _parameterCache;

    public static readonly Dictionary<Type, Type> TypeToControl = new()
        {
            // order matters, put more specific types first, then general system types last
            { typeof(StudySauce.Shared.Controls.PackControl.ViewPack), typeof(PackControl) },
            { typeof(StudySauce.Shared.Controls.PackControl.EditPack), typeof(PackControl) },
            { typeof(DataLayer.Entities.Card), typeof(CardControl) },
            { typeof(IEnumerable<StudySauce.Shared.Controls.CardsControl.EditCard>), typeof(CardsControl) },
            { typeof(IEnumerable<StudySauce.Shared.Controls.CardsControl.ViewCard>), typeof(CardsControl) },
            { typeof(IEnumerable<DataLayer.Entities.Answer>), typeof(AnswersControl) },
            //{ typeof(DateTime), typeof(DateControl) },
            //{ typeof(int), typeof(NumberControl) }
            { typeof(string), typeof(StringControl) },
            { typeof(object), typeof(TypeControl) },
        };

    public static Type GetControl(Type modelPropertyType)
    {
        foreach(var kvp in TypeToControl)
        {
            if(kvp.Key.IsAssignableFrom(modelPropertyType))
            {
                return kvp.Value;
            }
        }
        return typeof(TypeControl);
    }
    

    protected override void OnParametersSet()
    {
        // Only rebuild if the model actually exists and we haven't cached it yet
        if (_parameterCache == null)
        {
            _parameterCache = Model?.Select(prop => (
                prop,
                new Dictionary<string, object?>
                {
                    { "Model", prop },
                    { "ValueChanged", EventCallback.Factory.Create<object>(this, (val) => {})}
                }
            )).ToList();
        }

        var modelType = typeof(TModel);

        // Check if it's a generic collection or an array (excluding string)
        bool isEnumerable = modelType != typeof(string) &&
                           (modelType.IsArray ||
                            modelType.GetInterfaces().Any(i => i.IsGenericType && i.GetGenericTypeDefinition() == typeof(IEnumerable<>)));

        if (isEnumerable)
        {
            // Get the inner type name, e.g., List<User> -> "User-list"
            var innerType = modelType.IsArray
                ? modelType.GetElementType()
                : modelType.GetGenericArguments().FirstOrDefault();

            containerClass = $"{(innerType?.Name ?? "enumerable").ToSafe()}-list-container";
        }
        else
        {
            containerClass = $"{modelType.Name.ToSafe()}-form-container";
        }
    }
}
